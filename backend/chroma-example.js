// EXAMPLE OF HOW CHROMA DB DATA LOOKS LIKE SO I CAN GET A BETTER UNDERSTANDING

let d = {
  ids: [
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "10",
    "11",
    "12",
    "13",
    "14",
    "15",
    "16",
    "17",
    "18",
    "19",
    "20",
    "21",
    "22",
    "23",
    "24",
    "25",
    "26",
    "27",
    "28",
    "29",
    "30",
    "31",
    "32",
    "33",
    "34",
    "35",
    "36",
    "37",
    "38",
    "39",
    "40",
    "41",
    "42",
    "43",
    "44",
    "45",
    "46",
  ],
  embeddings: None,
  documents: [
    "Week 6-2\nAgile Software Development\nCOMPSCI 2ME3 Introduction to Software Development\n* Slides adapted from previous instructors of COMPSCI 2ME3/SFWREGN 2AA4\n\nWeek 6 Goals\n• Monday\nChapter 2 in Software\nEngineering Textbook\n• Software Processes: Part 2\n• Wednesday\nChapter 3 in Software\n• Agile Software Development: Part 1\nEngineering Textbook\n• Friday\n• Irene’s Research Talk",
    "Plan-Driven Development Recap\nThree traditional approaches we've studied:\n• Waterfall Model\n• Sequential phases: Requirements, Design, Implementation, Testing,\nDeployment; Each phase must complete before the next begins\n• Best for stable, well-understood projects\n• Incremental Development\n• System developed in increments, each increment adds new functionality\n• Best for projects where some requirements are known upfront\n• Integration and Configuration",
    "• Integration and Configuration\n• Reuse existing components and systems, focus on configuration and\nintegration\n• Best for when suitable reusable components exist\n3",
    "Plan-Driven Development Recap\nAll three assume relatively stable requirements and sequential progression\n4",
    "Modern Software Dev Challenges\nA large number of software projects using traditional methods fail or\n•\nare challenged\nAverage time to market for enterprise software: 18-24 months\n•\nBy the time of delivery, almost half of the features are never actually\n•\nused by customers\nWhy are nearly half of all built features never used?\nTwo fundamental problems that plan-driven models weren't designed\nto handle.\n5",
    'Challenge #1: Changing Requirements\nTraditional models assume we can\nplan and set requirements early,\nwhere requirements constantly\nevolve (and that\'s actually a good\nthing)\nInstagram: Started as location\n•\ncheck-in app "Burbn," completely\npivoted based on user behavior\nTwitter: Began as podcasting\n•\nplatform "Odeo," reinvented when\niTunes dominated podcasts\n6',
    'Challenge #1: Changing Requirements\nTraditional models assume we can\nThe Problem with Plan-Driven\nplan and set requirements early,\nModels:\nwhere requirements constantly\n• Changes require returning to\nevolve (and that\'s actually a good\nrequirements phase\nthing)\n• Extensive documentation needs\nupdating\nInstagram: Started as location\n•\n• Previous work may be scrapped\ncheck-in app "Burbn," completely\n• Change viewed as failure, not\npivoted based on user behavior\nlearning',
    'pivoted based on user behavior\nlearning\nTwitter: Began as podcasting\n•\nplatform "Odeo," reinvented when\niTunes dominated podcasts\n7',
    "Challenge #2: Speed Matters\nHow Software Development\nCycles Have Accelerated:\n• 1990s: 2-3 year development\ncycles were acceptable\n• 2000s: 12-18 months to stay\ncompetitive\n• 2010s: 6-month cycles became\nthe expectation\n• 2020s: Continuous delivery—\ndaily or weekly updates\n8",
    "Challenge #2: Speed Matters\nHow Software Development What Happens If You Take 2 Years\nCycles Have Accelerated: Today?\n• 1990s: 2-3 year development • Competitors beat you to market\ncycles were acceptable • Technology becomes outdated\n• 2000s: 12-18 months to stay • User needs evolve beyond your\ncompetitive solution\n• 2010s: 6-month cycles became • Investor patience evaporates\nthe expectation • Market opportunity closes\n• 2020s: Continuous delivery—\ndaily or weekly updates\n9",
    "Example: healthcare.gov\nThe Project: Launch Day, October 1, 2013:\nUS government healthcare • 250,000 people tried to access\nenrollment website the site\n• Budget: $1.7 billion • Only 6 people successfully\n• Timeline: 3.5 years of enrolled on day one\ndevelopment • Website crashed repeatedly\n• Approach: Traditional waterfall • Error messages everywhere\nmethodology • National embarrassment and\n• Expectation: 50,000 simultaneous political crisis\nusers\n10",
    "Example: healthcare.gov\n1. Requirements Locked Too Early 3. Technology Changed\n• Specifications finalized years • Development started in 2010, launched\nbefore launch 2013\n• No mechanism to incorporate • Web technologies evolved significantly\nlearning • Original choices became outdated\n• Assumptions about usage patterns 4. No Adaptive Capacity\ncompletely wrong • Built for 50K users, needed to handle\n2. No User Testing Until Too Late 250K",
    "2. No User Testing Until Too Late 250K\n• First real user interaction at launch • Couldn't scale or adjust when reality hit\n• No opportunity to discover • No working version to test until the\nproblems early very end\n• No iterative refinement\n11",
    "Modern Software Dev Challenges\nChallenge #1: Requirements Always Change\n• User needs evolve\n• Markets shift\n• Technology advances\n• Competitors innovate\n• Learning happens through building\nChallenge #2: Speed Matters More Than Ever\n• First to market wins\n• Continuous delivery expected\n• Feedback loops must be fast\n• Slow = irrelevant\n12",
    "Modern Software Dev Challenges\nChallenge #1: Requirements Always Change\n• User needs evolve\n• Markets shift\nWe Need:\n• Technology advances\n• Embrace and accommodate\n• Competitors innovate\nchange\n• Learning happens through building\n• Deliver value quickly and\nChallenge #2: Speed Matters More Than Ever frequently\n• Continuous customer\n• First to market wins\nfeedback\n• Continuous delivery expected\n• Adapt based on learning\n• Feedback loops must be fast\n• Slow = irrelevant\n13",
    "Agile Software Development\n17 software developers all frustrated with heavy-weight methodologies,\nmet and developed the manifesto for Agile Software Development\nThe Impact of Agile:\nFundamentally changed how software is built\n•\nSpread rapidly across the industry\n•\nNow the dominant approach for most software development\n•\nSpawned entire ecosystem of practices, tools, and certifications\n•\n14\n\nAgile Development\n15\nhttps://agilemanifesto.org/",
    "Four Agile Manifesto Values\n1. Individuals and Interactions Over Processes and Tools: People\nand communication matter most; adapt process to the team, not\nteam to process\n2. Working Software Over Comprehensive Documentation: Build\nworking software first; document what's necessary, not everything\npossible\n3. Customer Collaboration Over Contract Negotiation: Ongoing\npartnership throughout development; adapt to learning together\n4. Responding to Change Over Following a Plan: Plan, but expect",
    "plans to evolve; change means we're learning\n16",
    'Agile is Not Chaos\nWhile there is value in the items on the left, we value the items\non the tight more.\nAgile Is NOT: Agile IS:\n• No planning • Balanced approach\n• No documentation • Appropriate\n• No process documentation\n• No discipline • Lightweight process\n• Just "winging it" • High discipline\n• Excuses for poor quality • Deliberate adaptation\n• Quality built in\n17',
    "Twelve Principles of Agile\n1. Working software is the primary\n1. Our highest priority is to satisfy the customer\nmeasure of progress.\nthrough early and continuous delivery of\n2. Agile processes promote sustainable\nvaluable software.\ndevelopment. The sponsors, developers,\n2. Welcome changing requirements, even late\nand users should be able to maintain a\nin development. Agile processes harness\nconstant pace indefinitely.\nchange for the customer's competitive\n3. Continuous attention to technical",
    "3. Continuous attention to technical\nadvantage.\nexcellence and good design enhances\n3. Deliver working software frequently, from a\nagility.\ncouple of weeks to a couple of months, with\n4. Simplicity--the art of maximizing the\na preference to the shorter timescale.\namount of work not done--is essential.\n4. Business people and developers must work\n5. The best architectures, requirements, and\ntogether daily throughout the project.\ndesigns emerge from self-organizing",
    "designs emerge from self-organizing\n5. Build projects around motivated individuals.\nteams.\nGive them the environment and support they\n6. At regular intervals, the team reflects on\nneed, and trust them to get the job done.\nhow to become more effective, then\n6. The most efficient and effective method of\ntunes and adjusts its behavior\nconveying information to and within a\naccordingly.\ndevelopment team is face-to-face\nconversation.\n18",
    "Key Principles of Agile\nPrinciple Description\nCustomer Focus Customers should be closely involved throughout the\ndevelopment process. Their role is provide and prioritize new\nsystem requirements and to evaluate the iterations of the system.\nFrequent Delivery The software is developed in increments with the customer\nspecifying the requirements to be included in each increment.\nCollaboration & The skills of the development team should be recognized and",
    "Communication exploited. Team members should be left to develop their own ways\nof working without prescriptive processes.\nEmbrace Change Expect the system requirements to change and so design the\nsystem to accommodate these changes.\nSustainable Pace & Focus on simplicity in both the software being developed and in\nSimplicity the development process. Wherever possible, actively work to\neliminate complexity from the system. 19",
    "The Fundamental Mindset Shift\nFollow the plan → Adapt to change\nBig delivery → Iterative releases\nDocumentation-heavy → Working software\nIsolated teams → Collaborative culture\nHero developers → Sustainable pace\nChange is failure → Change is learning\nProcess over people → People over process\nContract protection → Customer partnership\nComprehensive documentation → Just enough documentation\nPredict and control → Inspect and adapt\n20",
    "Discussion #1\nWhat Does an Agile Developer's Day Look Like?\nImagine you're a software developer on an agile team building a mobile\nfood delivery app\nThink about:\nWhat time do you start?\nWhen do you actually write code?\nWhat meetings might you have?\nHow do you know what to work on?\nWho do you talk to during the day?\n21",
    "Discussion #1\nA Traditional Developer’s Day\n9:00am - Check email, attend status\nmeeting\n10:00am - Wait for requirements\nclarification\n11:00am - Code (alone at desk)\n12:00pm - Lunch\n1:00pm - More solo coding\n3:00pm - Weekly team meeting to\ndiscuss blockers\n4:00pm - Write documentation\n5:00pm - Go home\n22",
    "Discussion #1\nA Traditional Developer’s Day An Agile Developer’s Day\n9:00am - Check email, attend status 9:00am - Daily Standup (15 minutes) 9:15am -\nmeeting Pair programming on user story 11:00am -\n10:00am - Wait for requirements Quick code review with teammate\nclarification 12:00pm - Lunch\n11:00am - Code (alone at desk) 1:00pm - Continue development (solo or paired)\n12:00pm - Lunch 2:00pm - Brief chat with Product Owner to\n1:00pm - More solo coding clarify story",
    "1:00pm - More solo coding clarify story\n3:00pm - Weekly team meeting to 3:00pm - Write automated tests\ndiscuss blockers 4:00pm - Demo completed feature to team\n4:00pm - Write documentation 4:30pm - Backlog grooming meeting (2x per\n5:00pm - Go home week)\n5:00pm - Sprint retrospective (every 2 weeks)\n23",
    "Agile Practices: Daily Standup\nWhat It Is:\n• Entire team gathers (stand in circle or video call)\n• Exactly 15 minutes, every day\n• Same time, same place\nThe Three Questions: Each person answers:\n• What did I do yesterday?\n• What will I do today?\n• What's blocking me?\nPurpose:\n• Coordination and transparency\n• Quick identification of problems\n• Everyone knows what everyone else is doing\n• Blockers surface immediately\n24",
    "Agile Practices: Pair Programming\nHow It Works:\nTwo developers sit together\n• Driver: Types and implements\n• Navigator: Reviews, thinks ahead, suggests\nSwitch roles frequently (every 30-60 min)\nActually Effective:\n• Immediate bug detection: Navigator catches errors as they happen\n• Better design: Two brains thinking through problems\n• Knowledge sharing: Both learn the codebase\n• Natural mentoring: Senior helps junior\n• Fewer interruptions: Working together maintains focus",
    "• Higher code quality: Built-in code review\n25",
    "Agile Practices: Agile Ceremonies\nBacklog Grooming (1-2x per week, 1-2 hours):\n• Team + Product Owner\n• Review upcoming work\n• Break down large features into tasks\n• Estimate effort required\n• Clarify requirements\nSprint Review (Every 2-4 weeks, 1-2 hours):\n• Demo working software to stakeholders\n• Show what was completed this sprint\n• Get feedback\n• Discuss what to build next\n26",
    "Agile Practices: Agile Ceremonies\nSprint Retrospective (Every 2-4 weeks, 1-2 hours):\n• Team only (no managers ideally)\n• What went well this sprint?\n• What didn't go well?\n• What will we improve next sprint?\n• Focus on process improvement\nSprint Planning (Start of each sprint, 2-4 hours):\n• Team commits to work for next 2-4 weeks\n• Break down user stories into tasks\n• Discuss how to implement\n27",
    "Agile Development Practices\nLess Waiting:\nMore Collaboration:\n• Product Owner available for\n• Daily standup with entire team\nquestions\n• Pair programming sessions\n• Team can make decisions quickly\n• Quick chats with Product Owner\n• No long approval chains\n• Code reviews with teammates\n• Self-organizing authority\n• Regular demos and retrospectives\nContinuous Communication:\nShorter Feedback Loops:\n• Face-to-face preferred\n• Know immediately if blocked (daily\n• Informal and frequent\nstandup)",
    "• Informal and frequent\nstandup)\n• Rich, synchronous interaction\n• Bugs caught in minutes (pair\n• Build relationships and trust\nprogramming)\n• Features reviewed within days\n(sprint review)\n• Process improved every 2-4 weeks\n28\n(retrospective)",
    "Discussion #2\nWhat Roles Are Needed on an Agile Team?\nYou're forming an agile team to build that food delivery app.\nThink about:\nWho decides WHAT features to build?\nWho actually writes the code?\nWho manages the team?\nWho talks to customers?\nAny other roles needed?\n29",
    'Discussion #2\nAgile teams, especially using Scrum, have three core roles:\n• Product Owner - The "WHAT" person\n• Scrum Master - The "HOW" person\n• Development Team - The "BUILD" people\nKey Characteristics:\n• Flat structure, not hierarchical\n• Each role has specific authority\n• Shared accountability for results\n• Collaboration over command-and-control\n30',
    "Agile Roles: Product Owner\nPrimary Responsibility: Decide WHAT features to build and in what order\nKey Duties:\n• Manage the product backlog (prioritized list of work)\n• Write and define user stories (requirements)\n• Prioritize features based on business value\n• Accept or reject completed work\n• Represent customer and stakeholder needs\n• Make trade-off decisions\n• Ensure team builds the right thing\nWho Is This Person?\n• Business/domain expert, NOT a developer",
    "• Business/domain expert, NOT a developer\n• Deep understanding of customers and market\n• Decision-making authority\n• Available to team daily\n31",
    "Agile Roles: Scrum Master\nPrimary Responsibility: Ensure team follows agile practices and\nremove obstacles\nKey Duties:\n• Facilitate all agile meetings (standup, retrospective, planning, review)\n• Remove blockers that slow team down\n• Shield team from distractions and interruptions\n• Coach team on agile practices\n• Ensure process is working well\n• Servant leader to the team\nWho Is This Person?\n• Agile expert and facilitator\n• NOT a traditional project manager\n• No authority to assign tasks",
    "• No authority to assign tasks\n• Focused on how team works together\n32",
    "Agile Roles: Development Team\nPrimary Responsibility: Build working software\nTypical Composition (3-9 people):\n• Frontend developers\n• Backend developers\n• QA/Testers\n• UX/UI designers (sometimes)\n• Database specialists\n• DevOps engineers\nKey Characteristics:\n• Cross-Functional: All skills needed to deliver working software; No dependencies\non people outside the team\n• Self-Organizing: Team decides HOW to do the work; No task assignment from",
    "above; Members volunteer for tasks based on skills, interest, capacity Collective\nownership of code\n• Collaborative: Not individual heroes, but team success; Share knowledge and help\n33\neach other; Collectively responsible for outcomes",
    "Agile Roles\nStakeholders (Customers, Executives, Users)\nProduct Owner Scrum Master (WHAT to build) (HOW to work)\nDevelopment Team (BUILD it)\nFrontend Devs\nBackend Devs\nQA/Testers\nDesigners\n34\n\nScenario 1: A manager from another department keeps\ninterrupting developers during the sprint with urgent\nrequests that aren't in the sprint backlog.\nWho should hanlde this?\nThe Slido app must be installed on every computer you’re presenting from",
    "Scenario 2: The team needs to decide whether to use React\nor Angular for the frontend framework.\nWho should handle this?\nThe Slido app must be installed on every computer you’re presenting from\n\nAgile Summary\nOverall, agile development roles and practices are\nset up to emphasize:\n• Constant collaboration over isolated work\n• Face-to-face communication over documentation\n• Quick decisions over long approval chains\n• Trust and empowerment over command-and-\ncontrol\n37",
    "Week 6 Goals\n• Monday\nChapter 2 in Software\nEngineering Textbook\n• Software Processes: Part 2\n• Wednesday\nChapter 3 in Software\n• Agile Software Development: Part 1\nEngineering Textbook\n• Friday\n• Irene’s HCI Research Talk",
  ],
  uris: None,
  included: ["metadatas", "documents"],
  data: None,
  metadatas: [
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
  ],
};
