// EXAMPLE OF HOW CHROMA DB DATA LOOKS LIKE SO I CAN GET A BETTER UNDERSTANDING

let d = {
  ids: [
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "10",
    "11",
    "12",
    "13",
    "14",
    "15",
    "16",
    "17",
    "18",
    "19",
    "20",
    "21",
    "22",
    "23",
    "24",
    "25",
    "26",
    "27",
    "28",
    "29",
    "30",
    "31",
    "32",
    "33",
    "34",
    "35",
    "36",
    "37",
    "38",
    "39",
    "40",
    "41",
    "42",
    "43",
    "44",
    "45",
    "46",
    "47",
    "48",
    "49",
    "50",
    "51",
    "52",
    "53",
    "54",
    "55",
    "56",
    "57",
    "58",
    "59",
    "60",
    "61",
    "62",
    "63",
    "64",
    "65",
    "66",
    "67",
    "68",
    "69",
    "70",
    "71",
  ],
  embeddings: None,
  documents: [
    "Week 6-2\nAgile Software Development\nCOMPSCI 2ME3 Introduction to Software Development\n* Slides adapted from previous instructors of COMPSCI 2ME3/SFWREGN 2AA4\n\nWeek 6 Goals\n• Monday\nChapter 2 in Software\nEngineering Textbook\n• Software Processes: Part 2\n• Wednesday\nChapter 3 in Software\n• Agile Software Development: Part 1\nEngineering Textbook\n• Friday\n• Irene’s Research Talk",
    "Plan-Driven Development Recap\nThree traditional approaches we've studied:\n• Waterfall Model\n• Sequential phases: Requirements, Design, Implementation, Testing,\nDeployment; Each phase must complete before the next begins\n• Best for stable, well-understood projects\n• Incremental Development\n• System developed in increments, each increment adds new functionality\n• Best for projects where some requirements are known upfront\n• Integration and Configuration",
    "• Integration and Configuration\n• Reuse existing components and systems, focus on configuration and\nintegration\n• Best for when suitable reusable components exist\n3",
    "Plan-Driven Development Recap\nAll three assume relatively stable requirements and sequential progression\n4",
    "Modern Software Dev Challenges\nA large number of software projects using traditional methods fail or\n•\nare challenged\nAverage time to market for enterprise software: 18-24 months\n•\nBy the time of delivery, almost half of the features are never actually\n•\nused by customers\nWhy are nearly half of all built features never used?\nTwo fundamental problems that plan-driven models weren't designed\nto handle.\n5",
    'Challenge #1: Changing Requirements\nTraditional models assume we can\nplan and set requirements early,\nwhere requirements constantly\nevolve (and that\'s actually a good\nthing)\nInstagram: Started as location\n•\ncheck-in app "Burbn," completely\npivoted based on user behavior\nTwitter: Began as podcasting\n•\nplatform "Odeo," reinvented when\niTunes dominated podcasts\n6',
    'Challenge #1: Changing Requirements\nTraditional models assume we can\nThe Problem with Plan-Driven\nplan and set requirements early,\nModels:\nwhere requirements constantly\n• Changes require returning to\nevolve (and that\'s actually a good\nrequirements phase\nthing)\n• Extensive documentation needs\nupdating\nInstagram: Started as location\n•\n• Previous work may be scrapped\ncheck-in app "Burbn," completely\n• Change viewed as failure, not\npivoted based on user behavior\nlearning',
    'pivoted based on user behavior\nlearning\nTwitter: Began as podcasting\n•\nplatform "Odeo," reinvented when\niTunes dominated podcasts\n7',
    "Challenge #2: Speed Matters\nHow Software Development\nCycles Have Accelerated:\n• 1990s: 2-3 year development\ncycles were acceptable\n• 2000s: 12-18 months to stay\ncompetitive\n• 2010s: 6-month cycles became\nthe expectation\n• 2020s: Continuous delivery—\ndaily or weekly updates\n8",
    "Challenge #2: Speed Matters\nHow Software Development What Happens If You Take 2 Years\nCycles Have Accelerated: Today?\n• 1990s: 2-3 year development • Competitors beat you to market\ncycles were acceptable • Technology becomes outdated\n• 2000s: 12-18 months to stay • User needs evolve beyond your\ncompetitive solution\n• 2010s: 6-month cycles became • Investor patience evaporates\nthe expectation • Market opportunity closes\n• 2020s: Continuous delivery—\ndaily or weekly updates\n9",
    "Example: healthcare.gov\nThe Project: Launch Day, October 1, 2013:\nUS government healthcare • 250,000 people tried to access\nenrollment website the site\n• Budget: $1.7 billion • Only 6 people successfully\n• Timeline: 3.5 years of enrolled on day one\ndevelopment • Website crashed repeatedly\n• Approach: Traditional waterfall • Error messages everywhere\nmethodology • National embarrassment and\n• Expectation: 50,000 simultaneous political crisis\nusers\n10",
    "Example: healthcare.gov\n1. Requirements Locked Too Early 3. Technology Changed\n• Specifications finalized years • Development started in 2010, launched\nbefore launch 2013\n• No mechanism to incorporate • Web technologies evolved significantly\nlearning • Original choices became outdated\n• Assumptions about usage patterns 4. No Adaptive Capacity\ncompletely wrong • Built for 50K users, needed to handle\n2. No User Testing Until Too Late 250K",
    "2. No User Testing Until Too Late 250K\n• First real user interaction at launch • Couldn't scale or adjust when reality hit\n• No opportunity to discover • No working version to test until the\nproblems early very end\n• No iterative refinement\n11",
    "Modern Software Dev Challenges\nChallenge #1: Requirements Always Change\n• User needs evolve\n• Markets shift\n• Technology advances\n• Competitors innovate\n• Learning happens through building\nChallenge #2: Speed Matters More Than Ever\n• First to market wins\n• Continuous delivery expected\n• Feedback loops must be fast\n• Slow = irrelevant\n12",
    "Modern Software Dev Challenges\nChallenge #1: Requirements Always Change\n• User needs evolve\n• Markets shift\nWe Need:\n• Technology advances\n• Embrace and accommodate\n• Competitors innovate\nchange\n• Learning happens through building\n• Deliver value quickly and\nChallenge #2: Speed Matters More Than Ever frequently\n• Continuous customer\n• First to market wins\nfeedback\n• Continuous delivery expected\n• Adapt based on learning\n• Feedback loops must be fast\n• Slow = irrelevant\n13",
    "Agile Software Development\n17 software developers all frustrated with heavy-weight methodologies,\nmet and developed the manifesto for Agile Software Development\nThe Impact of Agile:\nFundamentally changed how software is built\n•\nSpread rapidly across the industry\n•\nNow the dominant approach for most software development\n•\nSpawned entire ecosystem of practices, tools, and certifications\n•\n14\n\nAgile Development\n15\nhttps://agilemanifesto.org/",
    "Four Agile Manifesto Values\n1. Individuals and Interactions Over Processes and Tools: People\nand communication matter most; adapt process to the team, not\nteam to process\n2. Working Software Over Comprehensive Documentation: Build\nworking software first; document what's necessary, not everything\npossible\n3. Customer Collaboration Over Contract Negotiation: Ongoing\npartnership throughout development; adapt to learning together\n4. Responding to Change Over Following a Plan: Plan, but expect",
    "plans to evolve; change means we're learning\n16",
    'Agile is Not Chaos\nWhile there is value in the items on the left, we value the items\non the tight more.\nAgile Is NOT: Agile IS:\n• No planning • Balanced approach\n• No documentation • Appropriate\n• No process documentation\n• No discipline • Lightweight process\n• Just "winging it" • High discipline\n• Excuses for poor quality • Deliberate adaptation\n• Quality built in\n17',
    "Twelve Principles of Agile\n1. Working software is the primary\n1. Our highest priority is to satisfy the customer\nmeasure of progress.\nthrough early and continuous delivery of\n2. Agile processes promote sustainable\nvaluable software.\ndevelopment. The sponsors, developers,\n2. Welcome changing requirements, even late\nand users should be able to maintain a\nin development. Agile processes harness\nconstant pace indefinitely.\nchange for the customer's competitive\n3. Continuous attention to technical",
    "3. Continuous attention to technical\nadvantage.\nexcellence and good design enhances\n3. Deliver working software frequently, from a\nagility.\ncouple of weeks to a couple of months, with\n4. Simplicity--the art of maximizing the\na preference to the shorter timescale.\namount of work not done--is essential.\n4. Business people and developers must work\n5. The best architectures, requirements, and\ntogether daily throughout the project.\ndesigns emerge from self-organizing",
    "designs emerge from self-organizing\n5. Build projects around motivated individuals.\nteams.\nGive them the environment and support they\n6. At regular intervals, the team reflects on\nneed, and trust them to get the job done.\nhow to become more effective, then\n6. The most efficient and effective method of\ntunes and adjusts its behavior\nconveying information to and within a\naccordingly.\ndevelopment team is face-to-face\nconversation.\n18",
    "Key Principles of Agile\nPrinciple Description\nCustomer Focus Customers should be closely involved throughout the\ndevelopment process. Their role is provide and prioritize new\nsystem requirements and to evaluate the iterations of the system.\nFrequent Delivery The software is developed in increments with the customer\nspecifying the requirements to be included in each increment.\nCollaboration & The skills of the development team should be recognized and",
    "Communication exploited. Team members should be left to develop their own ways\nof working without prescriptive processes.\nEmbrace Change Expect the system requirements to change and so design the\nsystem to accommodate these changes.\nSustainable Pace & Focus on simplicity in both the software being developed and in\nSimplicity the development process. Wherever possible, actively work to\neliminate complexity from the system. 19",
    "The Fundamental Mindset Shift\nFollow the plan → Adapt to change\nBig delivery → Iterative releases\nDocumentation-heavy → Working software\nIsolated teams → Collaborative culture\nHero developers → Sustainable pace\nChange is failure → Change is learning\nProcess over people → People over process\nContract protection → Customer partnership\nComprehensive documentation → Just enough documentation\nPredict and control → Inspect and adapt\n20",
    "Discussion #1\nWhat Does an Agile Developer's Day Look Like?\nImagine you're a software developer on an agile team building a mobile\nfood delivery app\nThink about:\nWhat time do you start?\nWhen do you actually write code?\nWhat meetings might you have?\nHow do you know what to work on?\nWho do you talk to during the day?\n21",
    "Discussion #1\nA Traditional Developer’s Day\n9:00am - Check email, attend status\nmeeting\n10:00am - Wait for requirements\nclarification\n11:00am - Code (alone at desk)\n12:00pm - Lunch\n1:00pm - More solo coding\n3:00pm - Weekly team meeting to\ndiscuss blockers\n4:00pm - Write documentation\n5:00pm - Go home\n22",
    "Discussion #1\nA Traditional Developer’s Day An Agile Developer’s Day\n9:00am - Check email, attend status 9:00am - Daily Standup (15 minutes) 9:15am -\nmeeting Pair programming on user story 11:00am -\n10:00am - Wait for requirements Quick code review with teammate\nclarification 12:00pm - Lunch\n11:00am - Code (alone at desk) 1:00pm - Continue development (solo or paired)\n12:00pm - Lunch 2:00pm - Brief chat with Product Owner to\n1:00pm - More solo coding clarify story",
    "1:00pm - More solo coding clarify story\n3:00pm - Weekly team meeting to 3:00pm - Write automated tests\ndiscuss blockers 4:00pm - Demo completed feature to team\n4:00pm - Write documentation 4:30pm - Backlog grooming meeting (2x per\n5:00pm - Go home week)\n5:00pm - Sprint retrospective (every 2 weeks)\n23",
    "Agile Practices: Daily Standup\nWhat It Is:\n• Entire team gathers (stand in circle or video call)\n• Exactly 15 minutes, every day\n• Same time, same place\nThe Three Questions: Each person answers:\n• What did I do yesterday?\n• What will I do today?\n• What's blocking me?\nPurpose:\n• Coordination and transparency\n• Quick identification of problems\n• Everyone knows what everyone else is doing\n• Blockers surface immediately\n24",
    "Agile Practices: Pair Programming\nHow It Works:\nTwo developers sit together\n• Driver: Types and implements\n• Navigator: Reviews, thinks ahead, suggests\nSwitch roles frequently (every 30-60 min)\nActually Effective:\n• Immediate bug detection: Navigator catches errors as they happen\n• Better design: Two brains thinking through problems\n• Knowledge sharing: Both learn the codebase\n• Natural mentoring: Senior helps junior\n• Fewer interruptions: Working together maintains focus",
    "• Higher code quality: Built-in code review\n25",
    "Agile Practices: Agile Ceremonies\nBacklog Grooming (1-2x per week, 1-2 hours):\n• Team + Product Owner\n• Review upcoming work\n• Break down large features into tasks\n• Estimate effort required\n• Clarify requirements\nSprint Review (Every 2-4 weeks, 1-2 hours):\n• Demo working software to stakeholders\n• Show what was completed this sprint\n• Get feedback\n• Discuss what to build next\n26",
    "Agile Practices: Agile Ceremonies\nSprint Retrospective (Every 2-4 weeks, 1-2 hours):\n• Team only (no managers ideally)\n• What went well this sprint?\n• What didn't go well?\n• What will we improve next sprint?\n• Focus on process improvement\nSprint Planning (Start of each sprint, 2-4 hours):\n• Team commits to work for next 2-4 weeks\n• Break down user stories into tasks\n• Discuss how to implement\n27",
    "Agile Development Practices\nLess Waiting:\nMore Collaboration:\n• Product Owner available for\n• Daily standup with entire team\nquestions\n• Pair programming sessions\n• Team can make decisions quickly\n• Quick chats with Product Owner\n• No long approval chains\n• Code reviews with teammates\n• Self-organizing authority\n• Regular demos and retrospectives\nContinuous Communication:\nShorter Feedback Loops:\n• Face-to-face preferred\n• Know immediately if blocked (daily\n• Informal and frequent\nstandup)",
    "• Informal and frequent\nstandup)\n• Rich, synchronous interaction\n• Bugs caught in minutes (pair\n• Build relationships and trust\nprogramming)\n• Features reviewed within days\n(sprint review)\n• Process improved every 2-4 weeks\n28\n(retrospective)",
    "Discussion #2\nWhat Roles Are Needed on an Agile Team?\nYou're forming an agile team to build that food delivery app.\nThink about:\nWho decides WHAT features to build?\nWho actually writes the code?\nWho manages the team?\nWho talks to customers?\nAny other roles needed?\n29",
    'Discussion #2\nAgile teams, especially using Scrum, have three core roles:\n• Product Owner - The "WHAT" person\n• Scrum Master - The "HOW" person\n• Development Team - The "BUILD" people\nKey Characteristics:\n• Flat structure, not hierarchical\n• Each role has specific authority\n• Shared accountability for results\n• Collaboration over command-and-control\n30',
    "Agile Roles: Product Owner\nPrimary Responsibility: Decide WHAT features to build and in what order\nKey Duties:\n• Manage the product backlog (prioritized list of work)\n• Write and define user stories (requirements)\n• Prioritize features based on business value\n• Accept or reject completed work\n• Represent customer and stakeholder needs\n• Make trade-off decisions\n• Ensure team builds the right thing\nWho Is This Person?\n• Business/domain expert, NOT a developer",
    "• Business/domain expert, NOT a developer\n• Deep understanding of customers and market\n• Decision-making authority\n• Available to team daily\n31",
    "Agile Roles: Scrum Master\nPrimary Responsibility: Ensure team follows agile practices and\nremove obstacles\nKey Duties:\n• Facilitate all agile meetings (standup, retrospective, planning, review)\n• Remove blockers that slow team down\n• Shield team from distractions and interruptions\n• Coach team on agile practices\n• Ensure process is working well\n• Servant leader to the team\nWho Is This Person?\n• Agile expert and facilitator\n• NOT a traditional project manager\n• No authority to assign tasks",
    "• No authority to assign tasks\n• Focused on how team works together\n32",
    "Agile Roles: Development Team\nPrimary Responsibility: Build working software\nTypical Composition (3-9 people):\n• Frontend developers\n• Backend developers\n• QA/Testers\n• UX/UI designers (sometimes)\n• Database specialists\n• DevOps engineers\nKey Characteristics:\n• Cross-Functional: All skills needed to deliver working software; No dependencies\non people outside the team\n• Self-Organizing: Team decides HOW to do the work; No task assignment from",
    "above; Members volunteer for tasks based on skills, interest, capacity Collective\nownership of code\n• Collaborative: Not individual heroes, but team success; Share knowledge and help\n33\neach other; Collectively responsible for outcomes",
    "Agile Roles\nStakeholders (Customers, Executives, Users)\nProduct Owner Scrum Master (WHAT to build) (HOW to work)\nDevelopment Team (BUILD it)\nFrontend Devs\nBackend Devs\nQA/Testers\nDesigners\n34\n\nScenario 1: A manager from another department keeps\ninterrupting developers during the sprint with urgent\nrequests that aren't in the sprint backlog.\nWho should hanlde this?\nThe Slido app must be installed on every computer you’re presenting from",
    "Scenario 2: The team needs to decide whether to use React\nor Angular for the frontend framework.\nWho should handle this?\nThe Slido app must be installed on every computer you’re presenting from\n\nAgile Summary\nOverall, agile development roles and practices are\nset up to emphasize:\n• Constant collaboration over isolated work\n• Face-to-face communication over documentation\n• Quick decisions over long approval chains\n• Trust and empowerment over command-and-\ncontrol\n37",
    "Week 6 Goals\n• Monday\nChapter 2 in Software\nEngineering Textbook\n• Software Processes: Part 2\n• Wednesday\nChapter 3 in Software\n• Agile Software Development: Part 1\nEngineering Textbook\n• Friday\n• Irene’s HCI Research Talk",
    "Assignment #1 COMPSCI 2ME3\nImplementing Geometric Elements in Java McMaster University\nCOMPSCI 2ME3 (Fall 2025)\nAssignment 1: Implementing Geometric Elements in Java\nDue: Friday, October 10th 11:59pm\nThis assignment asks you to implement various geometric elements with provided descriptions\nin Java. This assignment worths 10% toward your final grade and will be graded out of 100\npoints.\nThis assignment is to be done individually. Turning in a solution that does not reflect your",
    "individual work and understanding is considered academic dishonesty (see syllabus for full\nacademic dishonesty policies). However, you are encouraged to seek help from the course\nstaff using proper communication channels (any assignment related questions should be asked\nin the dedicated channel in the class Teams group, but do not share your code directly in\nthe channel). Start your work early so you will be able to ask questions and reach out for help.\nGitHub Set Up and Submit Instructions",
    "GitHub Set Up and Submit Instructions\nFollow these steps for setting up your directory for this assignment:\n1. Open the GitHub Classroom link for this assignment:\nhttps://classroom.github.com/a/opDtglQH\n2. Click the Accept this assignment button.\n3. You should see a page saying that “Your assignment repository has been created,” or\nsomething to that effect. There will be a repository url that looks something like this:\nhttps://github.com/mac-compsci2me3/assignment_name-\nyour_github_name.",
    "your_github_name.\nClick that link.\n4. Click the big green Code button to clone the repository for a copy on your own computer.\nYou will save all the files you create and changes you make to the files as part of this\nassignment inside this directory. You will submit your assignment by pushing your work to\nGitHub and remember to also “save” your work periodically by making commits and pushing\nyour progress to GitHub as you work.\nInstructions",
    "your progress to GitHub as you work.\nInstructions\nFor this assignment, please implement the classes described in the following, using Java\nprogramming language:\n1. AbstractElement: This should be an abstract class that serves as a base for other\ngeometric element classes (e.g., point, line, circle). It keeps track of the total number of\ninstances created for all geometric elements.\nIrene Ye Yuan Page 1 of 5",
    "Assignment #1 COMPSCI 2ME3\nImplementing Geometric Elements in Java McMaster University\n• Attributes:\no numberOfInstances: This attribute should track the number of instances that\ncreated from this geometric element.\n• Methods:\no getNumOfInstances(): Returns the total number of instances of this\ngeometric element.\n2. CollisionDetector: This should be an interface for detecting collisions or intersections\nbetween different geometric elements. Any class implementing this interface must provide",
    "functionality and actual implementation to check intersections with other geometric elements.\n• Methods:\no intersect(Point): Checks if this geometric element intersects with a given\nPoint.\no intersect(LineSeg): Checks if this geometric element intersects with a\ngiven LineSeg.\no intersect(Rectangle): Checks if this geometric element intersects with a\ngiven Rectangle.\no intersect(Circle): Checks if this geometric element intersects with a given\nCircle.",
    "Circle.\n3. Point: This should be a concrete class that represent a 2D point with x and y coordinates,\nextending AbstractElement class and implementing CollisionDetector interface. It is\ncapable of detecting intersections with other geometric elements and tracks the number of\nPoint instances created.\n• Attributes:\no x: The x-coordinate of the point.\no y: The y-coordinate of the point.\no numberOfInstances: Tracks the number of Point instances created.\n• Constructors:",
    "• Constructors:\no Point(): Default constructor that sets the point at (0, 0).\no Point(x, y): Constructor that sets the point at the given (x, y) coordinates.\n• Methods:\no getX(): Returns the x-coordinate of the point.\no getY(): Returns the y-coordinate of the point.\no getNumOfInstances(): Returns the total number of Point instances.\no Intersection methods as specified by CollisionDetector.\n4. LineSeg: This should be a concrete class that represents a line segment defined by two",
    "points (begin and end), which extends AbstractElement class and implements\nCollisionDetector interface. This class can detect intersections with other geometric\nelements and maintains a count of all LineSeg instances created.\n• Attributes:\no begin: The starting point of the line segment.\no end: The ending point of the line segment.\no numberOfInstances: Tracks the number of LineSeg instances created.\nIrene Ye Yuan Page 2 of 5",
    "Assignment #1 COMPSCI 2ME3\nImplementing Geometric Elements in Java McMaster University\n• Constructors:\no LineSeg(): Default constructor that initializes the line segment.\no LineSeg(begin, end): Constructor that initializes the line segment with\ngiven start and end points.\n• Methods:\no getBegin(): Returns the starting point.\no getEnd(): Returns the ending point.\no getNumOfInstances(): Returns the total number of LineSeg instances.\no Intersection methods as specified by CollisionDetector.",
    "5. Rectangle: This should be a concrete class that represents a rectangle defined by its left,\nright, top, and bottom boundaries (i.e., four numbers), and hence the four corners of this\nrectangle will be (left, top), (left, bottom), (right, top), and (right, bottom). This class should\nextend AbstractElement class and implement CollisionDetector interface. The class\ncan determine intersections with other geometric elements and keeps track of the number of\nRectangle instances created.",
    "Rectangle instances created.\n• Attributes:\no left: The left boundary of the rectangle.\no right: The right boundary of the rectangle.\no top: The top boundary of the rectangle.\no bottom: The bottom boundary of the rectangle.\no numberOfInstances: Tracks the number of Rectangle instances created.\n• Constructors:\no Rectangle(): Default constructor.\no Rectangle(left, right, top, bottom): Constructor that initializes the\nrectangle with the specified boundaries.\n• Methods:",
    "• Methods:\no getLeft(): Returns the left boundary.\no getRight(): Returns the right boundary.\no getTop(): Returns the top boundary.\no getBottom(): Returns the bottom boundary.\no getNumOfInstances(): Returns the total number of Rectangle instances.\no Intersection methods as specified by CollisionDetector.\n6. Circle: This should be a concrete class that represents a circle defined by a center point\nand a radius. The class should extend AbstractElement class and implement",
    "CollisionDetector interface. This class is capable of checking intersections with other\ngeometric elements and keeps track of the number of Circle instances created.\n• Attributes:\no center: The center point of the circle.\no radius: The radius of the circle.\no numberOfInstances: Tracks the number of Circle instances created.\n• Constructors:\nIrene Ye Yuan Page 3 of 5",
    "Assignment #1 COMPSCI 2ME3\nImplementing Geometric Elements in Java McMaster University\no Circle(): Default constructor.\no Circle(center, radius): Constructor that initializes the circle with the\ngiven center point (Point type) and radius (a number).\n• Methods:\no getCenter(): Returns the center of the circle.\no getRadius(): Returns the radius.\no getNumOfInstances(): Returns the total number of Circle instances.\no Intersection methods as specified by CollisionDetector.\nSome additional notes:",
    "Some additional notes:\n• Put your implemented AbstractElement, CollisionDetector, Rectangle,\nLineSeg, Point, Circle in separate java files and placed under the src folder in\nthe directory (you should have a total of 6 java files in your src folder).\n• You can consider using float type for all numbers associated with the geometric\nelements (e.g., x, y, center, radius).\n• You can assume all geometric elements will be created in a valid way, e.g., radius of a",
    "circle will be positive, the beginning point and the ending point of a line segment will not\ncoincide (so you don’t need to handle exception cases for this assignment yet).\n• When implement the intersection methods, you can assume all objects created from\nCircle and Rectangle are solid, like the examples in the following:\nin the example on the left above, rectangle.intersect(circle) and\ncircle.intersect(rectangle) should return true. If two objects connect at the",
    "edges or corners, which is the example on the right,\nrectangle.intersect(circle) and circle.intersect(rectangle) should\nreturn false.\n• A simple example of test code testElements.java is provided in on Avenue. You\ncan also add your own test cases for testing various intersection cases for different\ngeometric elements.\n• Make sure your code can compile and run in your submission. During grading, TA’s\nmanual intervention to fix any compilation errors will cause a penalty.",
    "• Make sure all six java files are included in your repository (AbstractShape.java,\nCollisionDetector.java, Point.java, LineSeg.java, Rectangle.java,\nCircle.java).\n• Make sure you commit and push your changes when you complete your assignment.\nIrene Ye Yuan Page 4 of 5",
    "Assignment #1 COMPSCI 2ME3\nImplementing Geometric Elements in Java McMaster University\nBonus\nThe bonus part will ONLY be considered part of your grading if all of your intersect methods and\ngeometric elements classes are correctly implemented. From a grade point of view, it is more\nefficient to focus on your work from the main instructions than rushing the bonus step.\nYou can get an extra 10 points if there is no redundant implementation for intersect",
    "methods. For example, intersection of rectangle and circle does not need to be implemented\ntwice in Rectangle.intersect(Circle) and Circle.intersect(Rectangle). Find a\nway to avoid redundancy.\nGrading Scheme\nThis assignment is graded according to several dimensions, classified into four categories: 1)\nprogram basic setups, 2) the correctness of implementation, and 3) coding style. The following\ntable show a summary of these dimensions with their associated marks:\nCategory Dimensions Points",
    "Category Dimensions Points\nProgram Basics All Java files are set up correctly in the project folder. 6\nAll required content is set up correctly based on the 50\nprovided instructions and requirements.\nProject can compile and run without errors. 10\nImplementation All attributes and methods are implemented correctly (e.g., 30\nCorrectness numberOfInstances, intersect methods). We will run various\ntest cases to test the implementation of these methods",
    "(similar to ones we provided in the starter code).\nCoding Style Codes are clear and readable, following good naming 4\nconvention in Java, code blocks have appropriate\nindentation, etc.\nExtra If all implementations are correct and no duplicate code 10\nused in the implementation of the intersect methods.\nTotal Points for A1: 100 + 10\nIrene Ye Yuan Page 5 of 5",
  ],
  uris: None,
  included: ["metadatas", "documents"],
  data: None,
  metadatas: [
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/Week 6-2 Agile Software Development - Part 1.pdf" },
    { source: "sample-docs/2ME3_Assignment_01_Fall25 copy.pdf" },
    { source: "sample-docs/2ME3_Assignment_01_Fall25 copy.pdf" },
    { source: "sample-docs/2ME3_Assignment_01_Fall25 copy.pdf" },
    { source: "sample-docs/2ME3_Assignment_01_Fall25 copy.pdf" },
    { source: "sample-docs/2ME3_Assignment_01_Fall25 copy.pdf" },
    { source: "sample-docs/2ME3_Assignment_01_Fall25 copy.pdf" },
    { source: "sample-docs/2ME3_Assignment_01_Fall25 copy.pdf" },
    { source: "sample-docs/2ME3_Assignment_01_Fall25 copy.pdf" },
    { source: "sample-docs/2ME3_Assignment_01_Fall25 copy.pdf" },
    { source: "sample-docs/2ME3_Assignment_01_Fall25 copy.pdf" },
    { source: "sample-docs/2ME3_Assignment_01_Fall25 copy.pdf" },
    { source: "sample-docs/2ME3_Assignment_01_Fall25 copy.pdf" },
    { source: "sample-docs/2ME3_Assignment_01_Fall25 copy.pdf" },
    { source: "sample-docs/2ME3_Assignment_01_Fall25 copy.pdf" },
    { source: "sample-docs/2ME3_Assignment_01_Fall25 copy.pdf" },
    { source: "sample-docs/2ME3_Assignment_01_Fall25 copy.pdf" },
    { source: "sample-docs/2ME3_Assignment_01_Fall25 copy.pdf" },
    { source: "sample-docs/2ME3_Assignment_01_Fall25 copy.pdf" },
    { source: "sample-docs/2ME3_Assignment_01_Fall25 copy.pdf" },
    { source: "sample-docs/2ME3_Assignment_01_Fall25 copy.pdf" },
    { source: "sample-docs/2ME3_Assignment_01_Fall25 copy.pdf" },
    { source: "sample-docs/2ME3_Assignment_01_Fall25 copy.pdf" },
    { source: "sample-docs/2ME3_Assignment_01_Fall25 copy.pdf" },
    { source: "sample-docs/2ME3_Assignment_01_Fall25 copy.pdf" },
  ],
};
